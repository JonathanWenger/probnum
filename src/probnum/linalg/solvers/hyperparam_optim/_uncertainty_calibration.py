from typing import List, Optional, Tuple, Union

import numpy as np

import probnum
from probnum.linalg.solvers.hyperparam_optim._hyperparameter_optimization import (
    HyperparameterOptimization,
)
from probnum.problems import LinearSystem

# Public classes and functions. Order is reflected in documentation.
__all__ = ["UncertaintyCalibration"]


class UncertaintyCalibration(HyperparameterOptimization):
    """Calibrate uncertainty of the covariance class based on Rayleigh coefficients.

    A regression model for the log-Rayleigh coefficient is built based on the
    collected observations. The degrees of freedom in the covariance class of the
    models for :math:`A` and :math:`H` are set according to the predicted
    log-Rayleigh coefficient for the remaining unexplored dimensions.

    Parameters
    ----------
    method :
        If supplied calibrates the output via the given calibration method. Available
        procedures are

        ====================================  ================
         Most recent Rayleigh quotient        ``adhoc``
         Running (weighted) mean              ``weightedmean``
         GP regression for kernel matrices    ``gpkern``
        ====================================  ================

    Examples
    --------
    """

    def __init__(self, method: str = "gpkern"):
        if method in ["adhoc", "weightedmean", "gpkern"]:
            self.calib_method = method
        else:
            raise ValueError("Calibration method not recognized.")
        super().__init__()

    def __call__(
        self,
        problem: LinearSystem,
        belief: "probnum.linalg.solvers.beliefs.LinearSystemBelief",
        actions: List[np.ndarray],
        observations: List[np.ndarray],
        solver_state: Optional["probnum.linalg.solvers.LinearSolverState"] = None,
    ) -> Tuple[
        Tuple[Union[np.ndarray, float], ...],
        Optional["probnum.linalg.solvers.LinearSolverState"],
    ]:
        iteration = len(actions)
        log_rayleigh_quotients = None
        if solver_state is not None:
            log_rayleigh_quotients = solver_state.log_rayleigh_quotients

        if log_rayleigh_quotients is None or not log_rayleigh_quotients:
            S = np.hstack(actions)
            Y = np.hstack(observations)
            log_rayleigh_quotients = np.log(np.einsum("nk,nk->k", S, Y)) - np.log(
                np.einsum("nk,nk->k", S, S)
            )

        if iteration == 1:
            # For too few iterations take the most recent Rayleigh quotient
            unc_scale_A = np.exp(log_rayleigh_quotients[-1])
            unc_scale_Ainv = np.exp(-log_rayleigh_quotients[-1])
        else:
            # Select calibration method
            if self.calib_method == "adhoc":
                logR_pred = self._most_recent_log_rayleigh_quotient(
                    log_rayleigh_quotients=log_rayleigh_quotients
                )
            elif self.calib_method == "weightedmean":
                logR_pred = self._weighted_average_log_rayleigh_quotients(
                    log_rayleigh_quotients=log_rayleigh_quotients, iteration=iteration
                )
            elif self.calib_method == "gpkern":
                logR_pred = self._gp_regression_log_rayleigh_quotients(
                    log_rayleigh_quotients=log_rayleigh_quotients,
                    iteration=iteration,
                    n=problem.A.shape[0],
                )
            else:
                raise ValueError("Calibration method not recognized.")
            # Set uncertainty scale (degrees of freedom in calibration covariance class)
            unc_scale_A = (np.exp(np.mean(logR_pred))).item()
            unc_scale_Ainv = (np.exp(-np.mean(logR_pred))).item()

        return (unc_scale_A, unc_scale_Ainv), solver_state

    def _most_recent_log_rayleigh_quotient(self, log_rayleigh_quotients: List[float]):
        """Most recent log-Rayleigh quotient."""
        return log_rayleigh_quotients[-1]

    def _weighted_average_log_rayleigh_quotients(
        self, iteration: int, log_rayleigh_quotients: List[float]
    ):
        """Weighted average of log-Rayleigh quotients."""
        deprecation_rate = 0.9
        return log_rayleigh_quotients * np.repeat(
            deprecation_rate, iteration
        ) ** np.arange(iteration)

    def _gp_regression_log_rayleigh_quotients(
        self, iteration: int, n: int, log_rayleigh_quotients: List[float]
    ):
        r"""GP regression on log-Rayleigh quotients.

        Assumes the system matrix to be generated by a :math:`\nu`-times differentiable
        kernel. By Weyl's theorem [1]_ the spectra of such kernel matrices approximately
        decay as :math:`\mathcal{O}(n^{-\nu-\frac{1}{2}})`. Accordingly, the prior mean
        function of the Gaussian process is chosen as :math:`\mu(n) = \log(
        \theta_0' n^{-\theta_1}) = \theta_0 - \theta_1 \log(n)`.

        References
        ----------
        .. [1] Weyl, Hermann. Das asymptotische Verteilungsgesetz der Eigenwerte
           linearer partieller Differentialgleichungen (mit einer Anwendung auf die
           Theorie der Hohlraumstrahlung). *Mathematische Annalen*, 71(4):441â€“479, 1912.
        """
        try:
            import GPy  # pylint: disable=import-outside-toplevel

            iters = np.arange(iteration) + 1
            # GP mean function via Weyl's result on spectra of Gram matrices for
            # differentiable kernels
            # ln(sigma(n)) ~= theta_0 - theta_1 ln(n)
            lnmap = GPy.core.Mapping(1, 1)
            lnmap.f = lambda n: np.log(n + np.finfo(np.float64).eps)
            lnmap.update_gradients = lambda a, b: None
            mf = GPy.mappings.Additive(
                GPy.mappings.Constant(1, 1, value=0),
                GPy.mappings.Compound(lnmap, GPy.mappings.Linear(1, 1)),
            )
            k = GPy.kern.RBF(input_dim=1, lengthscale=1, variance=1)
            m = GPy.models.GPRegression(
                iters[:, None],
                log_rayleigh_quotients[:, None],
                kernel=k,
                mean_function=mf,
            )
            m.optimize(messages=False)

            # Predict Rayleigh quotient
            remaining_dims = np.arange(iteration, n)[:, None] + 1
            return m.predict(remaining_dims)[0].ravel()
        except ImportError as err:
            raise ImportError(
                "Cannot perform GP-based calibration without optional "
                "dependency GPy. Try installing GPy via `pip install GPy`."
            ) from err
