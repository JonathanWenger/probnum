"""Posterior uncertainty calibration for linear solvers."""

from typing import List, Optional

import numpy as np

import probnum  # pylint: disable="unused-import"
from probnum.linalg.solvers._state import LinearSolverState
from probnum.linalg.solvers.belief_updates._symmetric_normal_linear_obs import (
    _SymmetricNormalLinearObsCache,
)
from probnum.linalg.solvers.hyperparam_optim._hyperparameter_optimization import (
    HyperparameterOptimization,
)
from probnum.linalg.solvers.hyperparams import (
    LinearSolverHyperparams,
    UncertaintyUnexploredSpace,
)
from probnum.problems import LinearSystem

# Public classes and functions. Order is reflected in documentation.
__all__ = ["UncertaintyCalibration"]


class UncertaintyCalibration(HyperparameterOptimization):
    """Calibrate uncertainty of the covariance class based on Rayleigh coefficients.

    A regression model for the log-Rayleigh coefficient is built based on the
    collected observations. The degrees of freedom in the covariance class of the
    models for :math:`A` and :math:`H` are set according to the predicted
    log-Rayleigh coefficient for the remaining unexplored dimensions.

    Parameters
    ----------
    method :
        Type of calibration method to use. Available choices are

        ====================================  ================
         Most recent Rayleigh quotient        ``adhoc``
         Running (weighted) mean              ``weightedmean``
         GP regression for kernel matrices    ``gpkern``
        ====================================  ================
    """

    def __init__(self, method: str = "gpkern"):
        if method in ["adhoc", "weightedmean", "gpkern"]:
            self.calib_method = method
        else:
            raise ValueError("Calibration method not recognized.")
        super().__init__()

    def __call__(
        self,
        problem: LinearSystem,
        belief: "probnum.linalg.solvers.beliefs.LinearSystemBelief",
        data: "probnum.linalg.solvers.data.LinearSolverData",
        solver_state: Optional["probnum.linalg.solvers.LinearSolverState"] = None,
    ) -> LinearSolverHyperparams:

        if solver_state is None:
            solver_state = LinearSolverState(
                problem=problem,
                belief=belief,
                data=data,
                cache=_SymmetricNormalLinearObsCache(
                    problem=problem, prior=belief, belief=belief, data=data
                ),
            )

        if solver_state.info.iteration == 1:
            # For too few iterations take the most recent Rayleigh quotient
            unc_scale_A = np.exp(solver_state.cache.log_rayleigh_quotient)
            unc_scale_Ainv = np.exp(-solver_state.cache.log_rayleigh_quotient)
        else:
            # Select calibration method
            if self.calib_method == "adhoc":
                logR_pred = self._most_recent_log_rayleigh_quotient(
                    log_rayleigh_quotients=solver_state.cache.log_rayleigh_quotient_list
                )
            elif self.calib_method == "weightedmean":
                logR_pred = self._weighted_average_log_rayleigh_quotients(
                    log_rayleigh_quotients=solver_state.cache.log_rayleigh_quotient_list,
                    iteration=solver_state.info.iteration,
                )
            elif self.calib_method == "gpkern":
                logR_pred = self._gp_regression_log_rayleigh_quotients(
                    log_rayleigh_quotients=solver_state.cache.log_rayleigh_quotient_list,
                    iteration=solver_state.info.iteration,
                    n=problem.A.shape[0],
                )
            else:
                raise ValueError("Calibration method not recognized.")
            # Set uncertainty scale (degrees of freedom in calibration covariance class)
            unc_scale_A = (np.exp(np.mean(logR_pred))).item()
            unc_scale_Ainv = (np.exp(-np.mean(logR_pred))).item()

        return UncertaintyUnexploredSpace(Phi=unc_scale_A, Psi=unc_scale_Ainv)

    def _most_recent_log_rayleigh_quotient(self, log_rayleigh_quotients: List[float]):
        """Most recent log-Rayleigh quotient."""
        return log_rayleigh_quotients[-1]

    def _weighted_average_log_rayleigh_quotients(
        self, iteration: int, log_rayleigh_quotients: List[float]
    ):
        """Weighted average of log-Rayleigh quotients."""
        deprecation_rate = 0.9
        return log_rayleigh_quotients * np.repeat(
            deprecation_rate, iteration + 1
        ) ** np.arange(iteration + 1)

    def _gp_regression_log_rayleigh_quotients(
        self, iteration: int, n: int, log_rayleigh_quotients: List[float]
    ):
        r"""GP regression on log-Rayleigh quotients.

        Assumes the system matrix to be generated by a :math:`\nu`-times differentiable
        kernel. By Weyl's theorem [1]_ the spectra of such kernel matrices approximately
        decay as :math:`\mathcal{O}(n^{-\nu-\frac{1}{2}})`. Accordingly, the prior mean
        function of the Gaussian process is chosen as :math:`\mu(n) = \log(
        \theta_0' n^{-\theta_1}) = \theta_0 - \theta_1 \log(n)`.

        References
        ----------
        .. [1] Weyl, Hermann. Das asymptotische Verteilungsgesetz der Eigenwerte
           linearer partieller Differentialgleichungen (mit einer Anwendung auf die
           Theorie der Hohlraumstrahlung). *Mathematische Annalen*, 71(4):441â€“479, 1912.
        """
        try:
            import GPy  # pylint: disable=import-outside-toplevel

            iters = np.arange(iteration + 1) + 1
            # GP mean function via Weyl's result on spectra of Gram matrices for
            # differentiable kernels
            # ln(sigma(n)) ~= theta_0 - theta_1 ln(n)
            lnmap = GPy.core.Mapping(1, 1)
            lnmap.f = lambda n: np.log(n + np.finfo(np.float64).eps)
            lnmap.update_gradients = lambda a, b: None
            mf = GPy.mappings.Additive(
                GPy.mappings.Constant(1, 1, value=0),
                GPy.mappings.Compound(lnmap, GPy.mappings.Linear(1, 1)),
            )
            k = GPy.kern.RBF(input_dim=1, lengthscale=1, variance=1)
            m = GPy.models.GPRegression(
                iters[:, None],
                np.array(log_rayleigh_quotients)[:, None],
                kernel=k,
                mean_function=mf,
            )
            m.optimize(messages=False)

            # Predict Rayleigh quotient
            remaining_dims = np.arange(iteration, n)[:, None] + 1
            return m.predict(remaining_dims)[0].ravel()
        except ImportError as err:
            raise ImportError(
                "Cannot perform GP-based calibration without optional "
                "dependency GPy. Try installing GPy via `pip install GPy`."
            ) from err
