from typing import Optional, Tuple

import numpy as np

import probnum
import probnum.random_variables as rvs
from probnum.linalg.solvers._state import LinearSolverState
from probnum.linalg.solvers.data import LinearSolverAction
from probnum.linalg.solvers.policies._policy import Policy
from probnum.problems import LinearSystem
from probnum.type import RandomStateArgType

# Public classes and functions. Order is reflected in documentation.
__all__ = ["ExploreExploit"]


class ExploreExploit(Policy):
    """Policy trading off exploration and exploitation.

    Returns an action given by :math:`s_i \\sim \\mathcal{N}(-\\mathbb{E}[
    \\mathsf{H}]r_{i-1}, \\mathbb{Cov}(\\mathsf{x})))` where :math:`r_{i-1} = A x_{i-1}
    - b` is the current residual and :math:`\\mathbb{Cov}(\\mathsf{x})` the
    uncertainty of the solution estimate.

    Parameters
    ----------
    tradeoff
    random_state
        Random state of the policy. If None (or :mod:`numpy.random`), the global
        :mod:`numpy.random` state is used. If integer, it is used to seed the local
        :class:`~numpy.random.RandomState` instance.
    """

    def __init__(
        self, tradeoff: float = 1.0, random_state: Optional[RandomStateArgType] = None
    ):
        self.tradeoff = tradeoff
        super().__init__(
            policy=self.__call__, is_deterministic=False, random_state=random_state
        )

    def __call__(
        self,
        problem: LinearSystem,
        belief: "probnum.linalg.solvers.beliefs.LinearSystemBelief",
        solver_state: Optional["probnum.linalg.solvers.LinearSolverState"] = None,
    ) -> LinearSolverAction:

        if solver_state is None:
            solver_state = LinearSolverState(problem=problem, belief=belief)

        # Exploitation direction
        expected_residual = belief.Ainv.mean @ (
            belief.A.mean @ belief.x.mean - belief.b.mean
        )

        if self.tradeoff == 0.0:
            action = -expected_residual
        else:
            # Exploration
            action = rvs.Normal(
                -expected_residual,
                self.tradeoff * belief.x.cov,
                random_state=self.random_state,
            ).sample()

        return LinearSolverAction(actA=action)
